# Jenkins란?

jenkins는 소프트웨어 개발 시 지속적으로 통합 서비스를 제공해주는 CI 툴이다.

여기서 지속적으로 통합을 서비스한다라는 뜻은 파이프라인을 통해 task들을 동기적 혹은 병렬적으로 실행시킴으로 써 

master branch로 marge 될 때 unit test, build, static code Analysis 등을 실행할 수 있도록 도와주는 역할을 하고 있다.

젠킨스는 DSL(Domain-Specific Language)와 그루비를 사용한다.
## 젠킨스와 그루비
젠킨스는 오랜 시간 동안 그루비 엔진을 포함해왔다. 이는 웹 인터페이스에서 불가능한 접근 및 기능과 깊은 수준의 스크립트 작업을 지원하기 위해 사용되었다.

# Jenkinsfile
젠킨스 파일은 DSL 스크립트를 사용하여 젠킨스 잡을 실행시킬 수 있고, 변경 추적과 분석이 가능해진다.

젠킨스는 Jenkinsfile이 있으면 이를 읽어서 코드를 수행한다. 

젠킨스는 보통 gradle을 통해 정의되어 실행되고 gradle에 의해 에러처리가 되는 일명 스크립트 방식의 파이프라인(pipelines-as-code)으로 처리되었다.

하지만 젠킨스 버전이 올라가면서 빌드 후 처리, 에러 확인, 상태 기반 알림 전달 등 젠킨스에서 가능해졌다.

```jenkinsfile
pipeline {
    agent any
    stages {
        stage('Source'){
            git brach : 'test', url: 'git@diyvb:repos/gradle-greetings'
            stash name : 'test-sources', includes: 'build,gradle,/src/test'
        }
        stage('Build'){
            
        }
    }
}
```
## jenkins configure
### pipeline
파이프 라인은 생성하는 역할을 담당한다. 파이프라인은 스크립트 방식으로 작성할 수 있으며, 서술적 방식으로 작성할 수 있다.

### folder
폴더는 여러 프로젝트를 하나로 묶는 방법이다. 폴더는 실제 운영체제의 폴더와 유사하다.

폴더의 경로는 프로젝트 경로의 일부가 된다.

### github organization
몇몇 소스 관리 플랫폼은 저장소를 조직 저장소로 묶는 기능을 제공한다.

젠킨스의 통합 기능은 사용자가 젠킨스 파이프라인 스크립트를 jenkinsfile 형태로 조직 저장소에 저장해 이를 기반으로 실행될 수 있게 지원한다.

현재는 github와 bitbucket의 조직 저장소가 지원되고, 다른 것들은 지원 예정이다.

### multibranch pipeline
멀티브랜치 파이프라인 타입의 프로젝트에서 젠킨스는 Jenkinsfile을 빌드 스크립트로 활용하게 된다. 

jenkinsfile을 포함하고 있는 새로운 브랜치가 프로젝트에 생성되면 젠킨스는 자동으로 해당 브랜치를 위한 새로운 젠킨스 프로젝트를 생성한다.

이 프로젝트는 깃 혹은 서브버전 저장소에 적용될 수 있다.


### 젠킨스2 재실행성
젠킨스 2에서는 마스터 노드에서 빌드가 다시 시작되었을 때, 실패한 이전 시점부터 다시 시작되는 기능을 제공한다.

이전 버전의 젠킨스에서는 이런 기능이 없어서 처음부터 다시 빌드를 진행해야 했다.


# Pipeline-as-code
파이프라인 코드에는 스크립트형 코드와 서술적 코드가 있다.
```jenkins
// 스크립트 방식 파이프 라인
node('worker_node1') {
    stage('Source') [ // 코드 가져오기
        // 깃 저장소에서 코드 가져오기
        git 'git@test:/home/git/repo/work.git'
    ]
    stage('Compile') { // 컴파일과 단위 테스트 수행
        //컴퍼알과 단위 테스트를 위해 그레이들 실행
        sh "gradle clean compileJava test"
    }
}
```

```Jenkins
// 서술적 방식 파이프 라인
pipeline {
    agent {label 'worker_node1'}
    stages {
        stage('Source') { // 코드 가져오기
            // 깃 저장소에서 코드 가져오기
            git 'git@test:/home/git/repo/work.git'
        }
    }
    stage('Compile') {
        steps {
            // 컴파일과 단위 테스트를 위해 그레이들 실행
            sh "gradle clean compileJava test"
        }
    }
}
```

## 스크립트 방식과 서술적 방식의 장단점.
### 스크립트 방식 장점
 - 대체로 더 적은 색션과 설명이 필요하다.
 - 더 많은 절차형 코드를 사용 가능하다.
 - 프로그램을 작성하는 것과 유사하다.
 - 전통적인 pipeline-as-code 모델로서 더 익숙하고 하위 호환성이 좋다.
 - 필요시 맞춤화된 동작을 수행하기 쉽다.
 - 더 복잡한 흐름과 파이프라인을 설계할 수 있다.
### 스크립트 방식 단점
 - 대체로 더 많은 프로그래밍이 필요하다.
 - 문법 검사가 그루비 언어와 환경에 국한된다.
 - 전통적인 젠킨스 모델과 연관이 적다.
 - 서술적 파이프라인에서 같은 내용의 구현이 가능하다고 가정한다면, 상대적으로 더 복잡하다.

### 서술적 파이프라인 장점
 - 더 구조화돼 전통적 젠킨스 웹 폼과 유사하다.
 - 필요한 것을 선언하는 것이 유연해 대체로 가독성이 좋다.
 - 블루 오션 화면의 인터페이스를 이용해 생성 가능하다.
 - 알림과 같이 기존 젠킨스 개념에 대응될 수 있는 섹션이 존재한다.
 - 문법 확인 및 에러 확인이 쉽다.
 - 파이프라인 사이의 일관성이 높다.
### 서술적 파이프라인 단점
 - 반복되는 로직에 대한 지원이 적다.(프로그램적 요소가 적다.)
 - 아직 발전 중이다. (기존 젠킨스에서 지원됐던 기능이 지원되지 않을 수 있다.)
 - 유연성이 더 적은 구조다.(맞춤화된 파이프라인 코드 작성이 더 어렵다.)
 - 현재 복잡한 파이프라인이나 워크플로우에 잘 적용되지 않는다.

## 마스터와 슬레이브
### 마스터
젠킨스 마스터는 젠킨스 인스턴스 제어에 중심이 되는 역할을 한다.

마스터에는 모든 권한과 설정이 있다. 

### 노드
노드는 젠킨스 잡을 실행시킬 수 있는 시스템을 의미한다. 여기에는 마스터 혹은 에이전트가 포함되며 이 둘을 지칭하는 용어로 사용되기도 한다.

도커와 같은 컨테이너를 의미할 때도 있다.

### 에이전트
에이전트는 구 젠킨스에서 슬레이브와 같은 의미로 사용된다.

에이전트는 마스터에 의해 관리되며 필요한 잡에 할당되어 실행된다.

스크립트 방식에서 'node' 라는 표현은 에이전트가 있는 시스템을 지칭한다.

### 노드와 에이전트
노드와 에이전트는 각각 서술적, 스크립트 방식의 문법에서 사용되는데, 개념적인 차이가 있다.

노드는 스크립트 방식의 파이프라인과 연관이 있는데, 기술적으로는 스텝이 된다. 즉, 수행돼야 할 행동을 유발시키는 역할을 한다.

반면 에이전트는 서술적 파이프라인의 명령어이다. 

```jenkins
// 스크립트 방식 파이프 라인
node('worker_node1') {
    stage('Source') { // 코드 가져오기
        // 깃 저장소에서 코드 가져오기
        git 'git@test:/home/git/repo/work.git'
    }
}

pipeline {
    agent {label 'worker_node1'}
    stages {
        stage('Source') { // 코드 가져오기
            // 깃 저장소에서 코드 가져오기
            git 'git@test:/home/git/repo/work.git'
        }
    }
}
```
두 파이프라인의 문법적 차이를 제외하고는 사실 큰 차이가 없다.

### Executor
Executor는 노드나 에이전트에서 잡을 실행시키는 장소이다. 

노드는 Executor를 여러개 갖을 수 있고 하나도 갖지 않을 수 있다. Executor의 개수에 따라 동시에 실행될 수 있는 잡의 개수가 정의된다.

잡이 즉시 수행되려면 사용 가능한 Executor가 있어야 한다. 그렇지 않으면 Executor를 사용 가능해질 때까지 기다리게 된다.

